// silica programming language
// Jacob M. Peck
// REPL proto

if(?REPL_DEBUG, writeln("  + Loading REPL.io"))

/*
 * Class: REPL
 *
 * The Read-Evaluate-Print-Loop for silica
 */
silica REPL REPL := Object clone do(
  //////////////////////////////////////////////////////////////////////////////
  // Group: Fields
  /* Topic: Object fields
   *
   * Note:
   *   Unless otherwise noted, all fields include a setSlot(value) method
   *
   * rl - the ReadLine object
   * currentNamespace - the current <Namespace> that the user occupies
   * mcmode - a flag, determining whether or not the line starts with a <MetaCommand>
   * silent - a flag, determining whether or not to provide textual output
   * parser - the <Parser> object
   * siren_in_path - a path determining where to drop information to siren
   * siren_out_path - a path determining where to read information from siren
   * siren_midi_path - a path describing the default location for MIDI files generated by siren
   */
  rl ::= ReadLine
  currentNamespace ::= silica namespace("home")
  mcmode ::= false
  silent ::= false
  parser ::= silica REPL Parser initialize
  siren_in_path ::= Path with(SILICA_DIR,"siren","siren_in")
  siren_out_path ::= Path with(SILICA_DIR,"siren","siren_out")
  siren_midi_path ::= Path with(SILICA_DIR,"siren","midi")
  
  //////////////////////////////////////////////////////////////////////////////
  // Group: Initializers 
  /*
   * Method: clone
   *
   * Returns the REPL object (singleton)
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   The singleton REPL object
   *
   * See Also:
   *   <initialize>
   */
  clone := method(self)
  
  /*
   * Method: initialize
   *
   * Set up the ReadLine prompt
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   self
   *
   * See Also:
   *   <clone>
   */
  initialize := method(
    self rl prompt = "silica> "
    self
  )
  
  //////////////////////////////////////////////////////////////////////////////
  // Group: ReadLine Functionality
  /*
   * Method: loadHistory
   *
   * Attempts to read the history from the .silica_history file.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   self
   *
   * See Also:
   *   <saveHistory>
   */
  loadHistory := method(
    try (
      if(SILICA_DIR != nil,
        self rl loadHistory(Path with(SILICA_DIR, ".silica_history"))
        ,
        self rl loadHistory(".silica_history")
      )
    )
    self
  )
  
  /*
   * Method: saveHistory
   *
   * Saves the history to the .silica_history file.
   *
   * Parameters:
   *   none
   *
   * Returns:
   *   self
   *
   * See Also:
   *   <loadHistory>
   */
  saveHistory := method(
    try (
      if(SILICA_DIR != nil,
        self rl saveHistory(Path with(SILICA_DIR, ".silica_history"))
        ,
        self rl saveHistory(".silica_history")
      )
    )
    self
  )
  
  //////////////////////////////////////////////////////////////////////////////
  // Group: REPL Functionality
  /*
   * Method: run(script, autoexec)
   *
   * Runs the REPL in one of three modes, depending on the parameters.
   * The modes are as follows:
   *   script and autoexec both nil - interactive mode
   *   script not nil and autoexec nil - scripting mode
   *   script and autoexec not nil - autoexec mode
   *
   * Parameters:
   *   script - the name of a script file
   *   autoexec - a flag, determining if autoexec mode is active
   *
   * Returns:
   *   self
   *
   * See Also:
   *   <interpretLine(in)>
   */
  run := method(script, autoexec,
    if(script != nil,
      // scripting mode
      file := File with(script)
      if(file exists not,
        writeln("Cannot run script \"" .. file path .. "\".  No such file.")
        silica exit = true;
        break
      )
      file := File with(script) openForReading
      if(autoexec == nil, writeln("Running script \"" .. file path .. "\".\n"))
      loop(
        in := file readLine
        if(in == nil, 
          if(autoexec == nil, silica exit = true) // exit after a script, but not after autoexec
          break
        )
        if(in strip == "",
          continue
        )
        if(in strip beginsWithSeq("##") not, // lines beginning with ## are comments
          self interpretLine(in)
        )
      )
      file close
      ,
      // interactive mode
      loop(
        in := self rl readLine(self rl prompt);
        self rl addHistory(in);
        self interpretLine(in);
        if(silica exit, 
          self saveHistory;
          break
        )
      )
    )
  )
  
  /*
   * Method: interpretLine(in)
   *
   * Interprets the input string by using <Parser>
   *
   * Parameters:
   *   in - the input string
   *
   * Returns:
   *   string
   *
   * See Also:
   *   <run(script, autoexec)>
   */
  interpretLine := method(in,
    out := list(list("-->", nil))
    vol := "$" .. silica Note volume
    inst := "@" .. silica Note instrument name
    
    processed := self parser preprocess(in, self)
    if(processed == nil,
      if(self silent not, writeln)
      return
    )
    if(?REPL_DEBUG, writeln("TRACE (interpretLine) received: " .. processed))
    
    transformed := self parser applyTransforms(processed)
    if(?REPL_DEBUG, writeln("TRACE (interpretLine) received: " .. processed))
    
    transformed splitNoEmpties foreach(tok,
      ret := self parser interpretToken(tok asMutable lowercase, true, self currentNamespace, self)
      if(ret first != nil, out append(ret first))
    )
    if(?REPL_DEBUG, writeln("TRACE (interpretLine) out = " .. out))
    
    repl_out := out map(tok, tok first) remove(nil)
    siren_out := out map(tok, tok second) remove(nil)
    
    if(siren_out size != 0, siren_out prepend(inst) prepend(vol) prepend("!" .. silica Note tempo))
    if(?REPL_DEBUG, writeln("TRACE (interpretLine): siren_out = " .. siren_out))
    if(REPL_SIREN_ENABLED,
      if(siren_out size != 0,
        self writeToSiren(siren_out prepend("render-sonic\n") join(" ") strip)
      )
    )
    if(repl_out size == 1, repl_out append("okay."))
    if(silent not, writeln(repl_out join(" ") strip))
  )
  
  /*
   * Method: writeToSiren(string)
   *
   * Writes the contents of string to a siren file
   *
   * Parameters:
   *   string - the siren string
   *
   * Returns:
   *   nil
   *
   * See Also:
   *   <readFromSiren>
   */
  writeToSiren := method(string,
    if(string == "",return nil)
    
    file := File with(Path with(siren_in_path,UUID uuidRandom .. ".siren")) openForUpdating
    if(?REPL_DEBUG, writeln("Sending to siren: " .. file path .. " " .. string))
    file write(string)
    file close
    
    nil
  )
  
  /*
   * Method: readFromSiren
   *
   * Not yet implemented
   *
   * See Also:
   *   <readFromSiren>
   */
  readFromSiren := method() // to be done
)
